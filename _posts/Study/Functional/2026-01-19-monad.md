---
title: "모나드가 뭘까?"
date: 2026-01-21 09:59:51 +0900
categories: ["Study", "Functional"]
tags: ["Functional"]
math: true
---

### Before Reading

사실 모나드에 대해선 이미 너무나도 많은 글들이 나와있고, 개중엔 내가 이야기하려는 내용과 크게 다르지 않은 것들도 있을 것이다. 그래도 예전에 내가 다른 곳에서 작성했던 글을 다시 정리하는 겸 해서 쓰는 것이니 필요한 누군가에겐 도움이 되기를...

### Prerequisites

#### Haskell

함수형 언어는 다양하게 존재하지만 모나드를 설명하는 데에는 하스켈만한 것이 없는데, 이는 하스켈만 오로지 순수한 함수형 언어이기 때문이다. 그래서 이 글에서도 먼저 하스켈의 기본 문법을 딱 필요한만큼만 짚고 넘어가려고 한다.
하스켈은 함수의 타입을 지정할 수 있으며, 당연히 추론 가능한 경우는 이를 생략할 수도 있다. 그리고 인자가 2개 이상인 함수의 경우, 아래처럼 괄호 없이 화살표 체이닝으로 연결한다.

``` haskell
add :: Int -> Int -> Int
add x y = x + y
```

또한 하스켈에도 클래스라는 개념이 있다. 하지만 OOP 언어의 그 클래스와는 개념이 많이 다르다. 하스켈의 클래스는 타입 클래스로, 특정 타입이 클래스의 인스턴스가 되려면 그 클래스에서 정의하는 함수들을 지원해야 한다는 제약사항을 나타낸 것이다.
가장 간단한 예시로 아래의 `Eq` 클래스를 들 수 있다.

``` haskell
class Eq a where
    (==), (/=) :: a -> a -> Bool
```

즉, 어떤 타입 a가 `Eq` 클래스로 인정받기 위해서는 `(==)` 연산자와 `(/=)` 연산자를 모두 정의해야 하며, 그러한 타입 a를 우리는 `Eq` 클래스의 인스턴스라고 부를 수 있다.

``` haskell
data Foo = Foo {x :: Integer, str :: String}
instance Eq Foo where
    (Foo x1 str1) == (Foo x2 str2) = (x1 == x2) && (str1 == str2)
    (Foo x1 str1) /= (Foo x2 str2) = not ((Foo x1 str1) == (Foo x2 str2))
```

위와 같이, `Int`와 `String`을 묶은 타입 `Foo`는 `(==)`와 `(/=)`를 `Eq` 클래스에서 요구하는 대로 잘 정의했으므로 `Eq` 클래스의 인스턴스가 될 수 있다.

#### Functor, Applicative Functor



```haskell

```