---
title: "Monad 3"
date: 2026-02-17 13:28:30 +0900
categories: ["Study", "Functional"]
tags: ["Functional"]
math: true
---

### Before starting

[2편](https://cloudholic.github.io/posts/monad-2/)을 통해 우리는 모나드를 제대로 정의하기 위한, 그리고 모나드를 확장하기 위한 기초적인 타입들을 알아봤다. 이번 글에서는 모나드와 관련된 다양한 응용 이론들을 알아볼 것이다.


### Kleisli Composition

지난 두 편의 글을 통해서 모나드는 함수형 언어에서 상당히 큰 축을 차지하고 있음을 알게 되었다. 그렇기 때문에 함수의 인자 혹은 리턴값에 모나드가 포함된 경우는 매우 자연스럽고, 또 상당히 많이 보게 된다. 당장 [1편](https://cloudholic.github.io/posts/monad-1/)에서 모나드를 설명하기 위해 사용했던 로그나 랜덤 함수들도 지금 와서 보면 일반적인 값을 인자로 받아 모나드를 리턴하는 함수들이다.


그런데 함수형 언어에서는 함수를 합성하는 일이 상당히 자주 일어나고, 또 그만큼 중요하다. 당장 1편의 예시도 모나드를 리턴하는 함수를 합성하기 위한 것이었다. 이제 그 고찰을 다시 가져와서, 조금 일반화를 시켜보자.


우선 한 가지 용어를 짚고 넘어가자. 모나드를 리턴하는 함수를 "Kleisli Arrow"라고 부른다. 보다 구체적으론 다음과 같다.

``` haskell
type Kleisli m a b = a -> m b
```

그리고 일반 함수의 합성과 다르게, 이런 Kleisli Arrow를 합성하는 연산자를 Kleisli Composition이라 부르며, `>=>` 기호를 사용한다. 일반 함수의 합성과 타입을 비교해보면 좀 더 명확하게 알 수 있다.

``` haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
```

`<=<`는 모양에서 짐작할 수 있듯, 역방향 Kleisli Composition을 뜻한다. 당연히 `g <=< f`와 `f >=> g`는 동일하다.


그러면 Kleisli Composition을 어떻게 구현할 수 있을까? `Option` 모나드에 대해 이걸 직접 구현해보려고 하면 다음과 같은 형태일 것이다.

``` fsharp
let validateParse s =
    match tryParseInt s with
    | Some x -> validatePositive x
    | None -> None

validateParse "42"  // Some 42
validateParse "-5"  // None
validateParse "abc" // None
```

역시나 패턴 매칭이다. 그런데 이건 전혀 일반화라고 볼 수 없다. 보다 일반적인, 임의의 모나드에 대해 Kleisli Composition을 어떻게 작성할 수 있을까? 위의 패턴 매칭 구현과, 모나드에서 제공하는 내장 함수들인 `fmap`, `<*>`, `return`, `>>=`를 잘 비교해보면, 다음과 같이 Bind로 어떻게든 간략화시킬 수 있다는 것을 알 수 있다.

``` fsharp
let validateParse s = tryParseInt s |> Option.bind validatePositive
```

여기까지 왔으면 이제 남은 일은 간단하다. `validateParse`는 `tryParseInt`와 `validatePositive`를 합성한 함수이므로, 보다 일반적인 `f >=> g`는 다음과 같이 쓸 수 있겠다.

``` fsharp
let (>=>) f g = fun x -> f x |> Option.bind g
let (<=<) g f = f >=> g
```

한 번 정방향을 정의한 후라면, 역방향은 정방향 구현을 이용해서 손쉽게 구현할 수 있다.
물론 위의 구현은 `Option` 모나드에 대한 것이라고 가정하고 구현되었기에, 실제로 F#에선 모나드마다 별도의 연산자가 필요하다. 이를 자세히 다루는 것은 모나드 자체를 이해하자는 이 글의 범위를 벗어나기 때문에 다른 글에서 자세히 다룰 예정이다. 참고로 하스켈에서는 모나드가 클래스로 정의되어 있기 때문에 Kleisli Composition의 일반적인 형태를 아래와 같이 구현할 수 있다.

``` haskell
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
f >=> g = \x -> f x >>= g
```

물론 이렇게 정의하지 않아도 함수형 그 자체인 언어답게 하스켈에서 이 정도는 기본적으로 제공하고 있다.


### Monad Transformer




### Natural Transformation

