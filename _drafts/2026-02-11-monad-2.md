---
title: "Monad 2"
date: 2026-02-11 13:28:30 +0900
categories: ["Study", "Functional"]
tags: ["Functional", "Monad"]
math: true
---

### Before starting

[1편](https://cloudholic.github.io/posts/monad-1/)을 통해 모나드가 뭐고 이게 왜 필요한지 알게 되었다. 그런데 사실 해당 글은 모나드를 제대로 정의하지도 않았고, 이걸 실질적으로 어떻게 활용할 수 있는지도 딱히 다루지 않았다. 이번 글에서는 모나드의 정의와 모나드를 확장 및 축소한 개념들에 대해 알아보자.


### Functor, Applicative Functor

1편의 말미에 "모나드는 Applicative Functor 위에서 정의된 개념이고, Applicative Functor는 Functor 위에서 정의된 개념이다." 라는 말을 했었다. 즉, 모나드를 제대로 이해하려면 우선 Functor와 Applicative Functor에 대해서 알아야 한다. 

#### Functor

먼저 Functor에 대해서 알아보자. 하스켈에서 Functor는 다음과 같이 정의되어 있다.

``` haskell
class Functor f where
    fmap    :: (a -> b) -> f a -> f b
```

여기서 `fmap` 함수는 `<!>` 연산자로도 표기한다.

여기에 정의된 `fmap` 함수의 의미를 생각해보자. 직관적으로 보면 primitive value를 대상으로 하는 함수 `a -> b`와 이 함수의 인자에 해당하는 값 `a`에 컨텍스트가 추가된 `f a`가 주어졌을 때, 이 함수의 리턴값에 컨텍스트가 추가된 형태인 `f b`를 리턴한다는 의미이다. 즉 컨텍스트를 유지한 채로 그 안의 값에 함수를 적용하는 것과 동일한 효과를 내게 해준다. 

만일 어떤 컨텍스트가 Functor조차 아니라면, 이 컨텍스트 내부의 값은 반드시 계산을 완료해서 primitive value로 치환해야만 우리가 마음대로 조작을 할 수 있게 된다. 그 이야기는 즉 컨텍스트를 유지한 상태로는 그 어떠한 조작도 불가능하다는 이야기와 동일하고, 이런 상황 속에선 모나드고 뭐고 제대로 정의가 될 수가 없다. 그렇기 때문에 모나드가 Functor 위에서 정의되어야만 한다는 것을 쉽게 알 수 있다.

여담으로, `fmap`이라는 이름에서 알 수 있듯이, 굳이 함수형 언어가 아니더라도 요새 많은 언어들이 제공해주는 `map` 함수가 이와 동일함을 알 수 있다. 예를 들자면 C#의 `Select`나 JS의 `map` 등이 이 `fmap`과 정확히 동일한 기능을 제공한다.


#### Applicative Functor

이번엔 Applicative Functor, 혹은 줄여서 Applicative에 대해서 알아보자. 하스켈에서는 다음과 같이 정의되어 있다.

``` haskell
class Functor f => Applicative f where
    pure    :: a -> f a
    (<*>)   :: f (a -> b) -> f a -> f b
```

여기서 `<*>` 연산자는 "Apply"라고 부른다.

Applicative는 Functor 위에서 정의된 만큼, 기본적으로 컨텍스트를 분리해서 다루기 위한 `fmap`은 이미 준비되어 있다. 그럼 Apply 연산자의 의미는 무엇일까? 이 연산자가 받는 인자들을 생각해보면, `a -> b` 함수 자체가 컨텍스트 안에 들어가있는 형태다. 즉, `f (a -> b)`는 이 컨텍스트 내부에서만 사용 가능한 함수라는 이야기가 된다. 이 컨텍스트 내부 함수와 컨텍스트가 추가된 값 `f a`를 제공해주면 컨텍스트가 추가된 리턴값 `f b`를 제공해준다는 의미이다.

``` fsharp
let (<*>) fOpt xOpt = 
    match fOpx, xOpt with
    | Some f, Some x -> Some (f x)
    | _ -> None

let add x y = x + y
Some add <*> Some 5 <*> Some 3  // Some 8
```

다른 언어에서 비교적 흔하게 찾아볼 수 있는 `fmap`과는 달리, Apply 연산자는 딱히 참고할만한 예시가 없어서 간단하게 구현했다. 위의 예시처럼 `Some`이라는 컨텍스트에 대응되는 Apply 연산자를 따로 정의해야 `Some add`와 같이 컨텍스트 내부에 정의된 함수를 우리가 자유롭게 꺼내서 쓸 수 있게 된다.

즉, Apply 연산자가 존재해야지만 우리는 컨텍스트 내부에 정의된 함수를 사용할 수 있다. 만일 어떤 컨텍스트가 Applicative Functor가 아니라면, 이 컨텍스트는 내부에 값을 저장하고 이를 조작할 수는 있으나 내부에 함수를 만들 수 없다는 이야기가 된다. 함수형 언어에서 함수를 마음대로 정의하지 못한다는 것은, 이 컨텍스트가 독립적인 기능을 하기 어렵다는 것을 의미한다.


그럼 마지막으로 Applicative와 모나드의 관계를 생각해보자. 우선 Applicative의 `pure`와 모나드의 `return`은 이름만 다를 뿐 함수 자체는 완벽히 동일하고, 이 함수의 필요성에 대해서는 1편에서 언급했으니 생략한다.

그럼 이제 Apply와 Bind를 비교해보면, Apply는 컨텍스트 외부에서 독립적인 연산을 지원하는 연산자고, Bind는 컨텍스트 내부에서 순차 실행을 지원하는 연산자다.

``` fsharp
// Applicative
let result1 =
    (fun x y z -> x + y + z)
    <!> Some 1
    <*> Some 2
    <*> Some 3

// Monad
let result2 =
    option {
        let! x = Some 1
        let! y = Some (x + 1)
        let! z = Some (x + y)
        return x + y + z
    }
```

위의 코드가 Applicative와 모나드의 차이를 잘 보여주고 있다. Apply 연산자는 어디까지나 각각의 독립적인 컨텍스트에 대한 연산만을 제공해준다. 하지만 Bind 연산자는 `M a -> (a -> M b) -> M b`로 정의되며, 그 중에서도 `a -> M b` 부분을 보면 알 수 있듯이 이미 컨텍스트가 추가된 `M a`라는 값을 받으면서 모나드 내부의 연산은 그 컨텍스트가 제거된 `a`를 인자로 요구하고 있다. 이 말은 모나드 내부에서는 컨텍스트를 마음대로 제거한 상태로 연산이 가능하다는 의미이고, 그렇기 때문에 모나드 내에서 이전 결과에 의존한, 순차 실행이 가능하다는 의미가 된다.

다만, 모나드의 본질을 생각해보면, Apply가 없는 모나드는 어딘가 부족하다. 모나드라는 것이 근본적으로 side-effect를 자유롭게, 함수형 언어의 방식으로 다루기 위해 고안된 개념인 만큼, 모나드 내부에서의 자유로운 연산만으로는 이 목적을 달성하기 어렵고, Apply를 같이 지원하여 동일한 모나드끼리의 연산 역시 지원해야 자연스럽다. 그렇기 때문에 모나드는 Applicative 위에서 정의되어야 하며, 반대로 Applicative는 모나드보다 약한 개념으로 취급된다.


### Monad Law

그럼 정말 Applicative이면서 `Bind`와 `Return`이 타입에 맞게 제공되기만 하면 전부 모나드일까? 다음의 예시를 보자.

``` fsharp
type WeirdOption<'a> = 
    | WeirdSome of 'a 
    | WeirdNone

let weirdBind m f =
    match m with
    | WeirdSome x -> WeirdNone
    | WeirdNone -> WeirdNone

let weirdReturn x = WeirdSome x
```

이러한 타입 `WeirdOption`은 모나드일까?

``` fsharp
weirdReturn 5 |> weirdBind (fun x -> weirdReturn (x * 2))
// Expected: WeirdSome 10
// Actual: WeirdNone
```

위의 코드를 보면 우리가 기대한 값과 실제로 나오는 값이 전혀 다름을 알 수 있다. 이 때문에 모나드에 대한 추가적인 규칙들이 필요하고, 우리는 이걸 "Monad Law"라고 부른다. 이 법칙에는 아래의 3가지가 있다.


#### Left Identity

``` fsharp
return x >>= f ≡ f x
```

즉, `return` 한 후 바로 `bind`를 하면 그냥 함수를 호출한 것과 동일해야만 한다.

#### Right Identity

``` fsharp
m >>= return ≡ m
```

즉, `bind` 한 후 바로 `return`을 하면 원래 값이 그대로 나와야만 한다.


#### Associativity

``` fsharp
(m >>= f) >>= g ≡ m >>= (fun x -> f x >>= g)
```



### Alternative, MonadPlus

이번에는 모나드를 확장해보자.


### Traversable, Foldable