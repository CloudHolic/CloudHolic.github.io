---
title: "Monad in F#"
date: 2026-02-08 13:28:30 +0900
categories: ["Study", "Functional"]
tags: ["Functional", "F#"]
math: true
---

### Before Reading

![저번 글](https://cloudholic.github.io/posts/monad/)에서 모나드에 대해 알아봤다. 모나드를 한 마디로 요약하면 side-effect를 함수형 언어의 방식으로 처리하는 이론적 배경이자 디자인 패턴이다. 그만큼 함수형 언어에서의 핵심 개념이기 때문에 함수형이 주인 언어에서는 이 모나드를 사용할 다양한 방법들을 매우 직설적으로 제공해준다. 실제로 하스켈에서는 이 모나드가 이름 그대로 Monad라고 정의되어 있으며, 그 내용도 모나드의 수학적 정의와 크게 다르지 않다. 그런데 유독 .NET 기반의 함수형 언어인 F#에서는 모나드라는 단어가 직접적으로 표시되지 않고 숨겨져 있다.

### Computation Expression

우선 F#에선 모나드 대신 "Computation Expression", 즉 계산식이라는 명칭을 사용한다. 명칭뿐만 아니라 사용하는 형태도 좀 특이한데, 다음과 같이 사용한다.

``` fsharp
builder-expr { cexpr }
```

`builder-expr`에 그 계산식의 이름이 들어가며, 이후 중괄호 안에 계산식 내에서 해야하는 작업들이 들어가는 형태다. 그리고 계산식을 좀 더 편하게 쓸 수 있도록, 계산식 내에서만 사용 가능한 특수한 키워드들을 제공한다. 이들은 `let!`, `do!`, `and!` 등과 같이 원래의 키워드에 `!`가 붙은 형태로, 공통적으로 계산식 속에 있는 그 값을 직접 다루게 해준다.

``` fsharp
let result = 
    option {
        let! x = Some 5
        let! y = Some 3
        return x + y
    }
```

위 코드에서, `x`와 `y`에는 각각 `5`와 `3`이 바인딩되고, 그로 인해 `x + y`연산을 정상적으로 수행할 수 있게 해준다. 만일 `let!` 대신 `let`을 사용했다면, `x`는 `Some 5`, `y`는 `Some 3`이 그대로 바인딩될 것이라 `x + y`를 계산하기 위해 또 복잡한 방법을 사용해야 했을 것이다.
(사실 F#에서 `option` 계산식은 기본적으로 제공하는 계산식은 아니다. 하지만 대충 어떤 느낌인진 알지 않는가?)

그럼 이제 F#에서 기본으로 제공하는 아래 4가지 계산식들을 보면서 실제 사용법을 파악해보자.


#### seq

`seq` 계산식은 Sequence Builder이다. 즉, 계산식 안의 구문을 통해 `seq<'T>` 타입을 만들어내며, 이 `seq<'T>`라는 타입은 배열, 리스트, 기타 다른 모든 컬렉션의 부모격이 된다. 즉, C#의 `IEnumerable<T>`와 동일하다고 볼 수 있다. 

``` fsharp
let seqA = seq { 0..15 }    // 0, 1, ..., 15

let seqB = seq {
    yield 1
    yield 2
    for x in [3..10] do
        yield x * x
}   // 1, 2, 9, 16, 25, ..., 100

let seqC = seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5 }
}   // 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..., 1, 2, 3, 4, 5
```

`seqA`와 `seqB`는 코드와 그 결과로 나올 시퀀스만 봐도 무슨 일을 하는지 손쉽게 알 수 있으니 넘어가자. 참고로 `yeild` 키워드는 C#에서의 그것과 동일하다. 

`seqC`의 경우 `yeild!`라는 키워드가 쓰였는데, 이는 `let`과 `let!`의 관계와 동일하다. 즉, 계산식 안의 내부 원소들을 꺼내서 `yeild` 작업을 수행하는 것이라고 보면 된다. 이중 시퀀스를 단일 시퀀스로 펼치는 작업이기 때문에 이를 flatten이라고 부른다.

그 외에도 `Seq.empty`, `Seq.init`, `Seq.singleton` 등 다양한 보조 함수들이 정의되어 있다. 그런데 주의할 점은 `seq`에는 `let!` 바인딩이 존재하지 않는다. 이에 대한 자세한 내용은 후술한다.


#### async

`async` 계산식은 Async Builder이다. 요즘 대부분의 언어는 다 갖고 있다는 바로 그 비동기 지원과 관련된 계산식이다. 사실 생각해보면 당연한게, 비동기 작업이야말로 정말 대표적인 "필수불가결한 side-effect"에 해당한다. 그러니 이를 함수형 언어의 방식으로 처리하려면 모나드 형태로 처리할 수 밖에 없다.

``` fsharp

```

#### task


#### query